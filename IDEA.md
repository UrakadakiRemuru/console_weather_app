# Погода в твоей консоли

# Содержание

0. [Предисловие](#0-предисловие)
1. [Получение информации о погоде по конкретному городу](#1-Получение-информации-о-погоде-по-конкретному-городу)
   1. [Использование API Geocoding для поиска местоположения](#11-использование-api-geocoding-для-поиска-местоположения)
   2. [Решение проблем с неоднозначностью названия города](#12-решение-проблем-с-неоднозначностью-названия-города)
2. [Получение информации о погоде по текущему местоположению](#2-получение-информации-о-погоде-по-текущему-местоположению)
3. [Хранение истории запросов и ее отображение](#3-хранение-истории-запросов-и-ее-отображение)
   1. [Хранение данных в базе данных](#31-хранение-данных)
   2. [Отображение данных пользователю](#32-отображение-данных)
4. [Интерфейс программы и возможные неприятности](#4-интерфейс-программы-и-возможные-неприятности)
   1. [Знакомство с пользователем](#41-знакомство-с-пользователем)
   2. [Общие сведения](#42-общие-сведения)
      1. [Погода по названию города, команда '\вгороде'](#1-погода-по-названию-города-команда-вгороде)
      2. [Погода по текущей локации, команда '\влокации'](#2-погода-по-текущей-локации-команда-влокации)
      3. [История запросов пользователя '\висторию'](#3-история-запросов-пользователя-команда-висторию)
      4. [Погода по текущей локации, команда '\внастройки'](#4-пользовательские-настройки-команда-внастройки)


## 0. Предисловие
В силу того, что мы будем работать с API нам будет необходим пользоваться библиотекой `requests`. Также API скорее всего будут
иметь какие-то ключи или иные чувствительные данные. Эти данные будет хранить в .env файле, для взаимодействия с ним
воспользуемся библиотекой [`python-dotenv`](https://pypi.org/project/python-dotenv/).

## 1. Получение информации о погоде по конкретному городу
Для получения информации по конкретному городу будет использоваться [`openweathermap`](https://openweathermap.org/current). 
Для использования данного API необходимо знать __широту__ и __долготу__ для определения локации, в которой мы хотим узнать погоду.

Для определения широты и долготы нам может помочь [`geocoding-api`](https://openweathermap.org/api/geocoding-api).
Данное API требует название города, для получения широты и долготы. Однако есть нюанс, названия городов не являются уникальными.
В связи с этим могут возникать ситуации, когда API вернет ни один город, а несколько.

В этом случае можно поступить несколькими способами:

### 1.1 Использование API Geocoding для поиска местоположения

Можно изначально просить пользователя вводить страну и город. `geocoding-api` поддерживает уточнение страны расположения города
посредством использования кода страны в формате ISO 3166. Как получать код страны в таком формате?
Можно воспользоваться библиотекой [`pycountry`](https://pypi.org/project/pycountry/), которая имеет возможность по названию страны предоставить ее код в нужном формате.
Однако и тут есть нюанс. Название страны требуется на английском языке. Но и тут есть решение: можно воспользоваться гугл переводчиком
(не пользователю, конечно, а разработчику!). Для этого можно взять библиотеку [`googletrans`](https://py-googletrans.readthedocs.io/en/latest/).
Что мы имеем в случае этого варианта исполнения:

-> Получаем от пользователя название страны и города

-> переводим название страны при помощи `googletrans`
```python
>>> from googletrans import Translator
>>> translator = Translator()
>>> translator.translate("Россия", src='ru', dest='en').text 
Russia
``` 
-> используем `pycountry` для получения кода страны
```python
>>> import pycountry
>>>pycountry.countries.get(name="Russia").alpha_2
RU
```
-> получаем широту и долготу по названию города и коду страны в `geocoding-api`
```json5
{
"name":"London",
"local_names":{
  //...
  "ru":"Лондон",
  //...
},
"lat":51.5073219,
"lon":-0.1276474,
"country":"GB",
"state":"England",
}
```
-> наконец-то добираемся до погоды, полученной в ответ от `openweathermap`.
```json5
                          
{ // ответ можем получить на русском! в параметрах запроса нужно lang=ru
   //...
   "weather": [
      {
         //..
         "main": "Rain",
         "description": "moderate rain",
         //..
      }
   ],
   //...
   "main": {// В параметрах запроса можно выбрать систему СИ: units=metric
      "temp": 284.2,
      "feels_like": 282.93, 
      //..
   },
   //...
   "wind": {
      "speed": 4.09,
      //...
   },
   //...
}
```

Стоит учитывать, что пользователь - это пользователь, как бы странно это не звучало. Поэтому он наверняка будет делать так,
как это удобное ему: он совсем может не следовать нашим правилам. Если мы ему будем их агрессивно навязывать через выводы в консоль
страшных ошибок и требований о том, что он ОБЯЗАН ввести данные так, как этого хочется разработчику, то он просто закроет это
приложение. В связи с этим предлагаю второй (дополнительный) вариант реализации.

### 1.2 Решение проблем с неоднозначностью названия города

`geocoding-api` позволяет определить количество выводимых совпадений по названию города, в случае если по запросу удалось найти несколько вариантов ответа.
В этом случае можно уточнить у пользователя, в каком же он городе все-таки хочет узнать погоду. Это можно реализовать посредством дополнительного вывода в консоль данных
в формате: `i. название города, страна`.

И ожидать от пользователя чиселку. После реализация следующая: 

-> получаем широту и долготу, исходя из выбора пользователя

-> наконец-то добираемся до погоды, полученной в ответ от `openweathermap`.

## 2. Получение информации о погоде по текущему местоположению

Получать широту и долготу из текущего местоположения можно при помощи библиотеки `geocoder`. Определение текущего местоположения
происходит из IP-адреса пользователя. Безусловно, не самый лучший вариант в плане точности, с другой стороны, нет необходимости
заводить API-ключи, делиться с кем-то своими данными, использовать Wi-Fi маршрутизаторы и даже не нужно пользоваться GPS.
```python
>>> import geocoder
>>> g = geocoder.ipinfo('me')
>>> g.latlng
[45.413140, -75.656703]
```

Ну а зная широту и долготу, проблем с получением погоды из `openweathermap` не будет.

## 3. Хранение истории запросов и ее отображение.

### 3.1 Хранение данных

В этом случае имеет смысл воспользоваться СУБД. Самый адекватный вариант для такого проекта использовать `sqlite3`. Даная
библиотека является встроенной, поэтому даже дополнительных манипуляций производить не придется.

Что касается наполненности базы данных, то я считаю, что имеет смысл создать 4 таблицы:
#### 1. user_request_history

Таблица с информацией о запросе пользователя. 

|    id    | city | country | is_current_location | counter | updated_at |
|:--------:|:----:|:-------:|:-------------------:|:-------:|:----------:|

    id - целое число, первичный ключ
    city - строка, название города
    country - строка, название страны
    is_current_location - bool, использовал ли пользователь запрос по текущему местоположению
    counter - целое число, количество запросов, которое отправил пользователь
    updated_at - datetime, время последнего запроса

#### 2. request_params_to_openweather

Таблица для хранения широты и долготы, которые необходимы для отправления запроса в `openweathermap`.

|    id    | latitude | longitude |request_time|
|:--------:|:--------:|:--------:|:------------:|

    id - целое число, первичный ключ
    latitude - число с плавающей точкой, широта
    longitude - число с плавающей точкой, широта
    request_time - datetime, дата время в формате времени пользователя

#### 3. response_from_openweather

Таблица для хранения ответа от `openweathermap`.

|    id    | weather | temperature | feels_like | wind_speed | response_time |
|:--------:|:-------:|:-----------:|:----------:|:----------:|:-------------:|

    id - целое число, первичный ключ
    city - строка, название города
    weather - строка, погодные услвоия
    temperature - целое число, температура
    feels_like - целое число, ошущается как
    wind_speed - скорость ветра
    response_time - datetime, дата время в формате времени пользователя
    
#### 4. request_response_connection

Связующая таблица, являющаяся объединяющей для таблиц 1 - 3.

|    id    | user_request | request | response |
|:--------:|:------------:|:-------:|:--------:|
    id - целое число, первичный ключ
    user_request - целое число, внешний ключ на таблицу user_request_history
    request - целое число, внешний ключ на таблицу request_params_to_openweather
    response - целое число, внешний ключ на таблицу response_from_openweather

#### 5. user_preferences

Таблица для хранения пользовательских настроек.

| is_first_time | language | units | instruction_on_start |
|:-------------:|:--------:|:-----:|:--------------------:|
    is_first_time - bool, маркер на запуск приложения впервые
    language - строка, предпочитаемый языкы (целесообразно хранить в ISO 3166)
    units - целое число, one of [standart, metric, imperial]. (как на физике, метрическая или имперская)
    instruction_on_start - bool, маркер о отображении инструкции при первом запуске

1. Заполнение [первой таблицы](#1-user_request_history) происходит по мере получения данных от пользователя.
При помощи сетчика будем определять популярность запроса. Проверка на повторяемость будет осуществляться следующим образом:
если пользователь вводит данные страны и города / города, то сравнение будет произоводиться по соответствующим полям
[первой таблицы](#1-user_request_history); если же пользователь выбирает текущую локацию, то сравнение будет производиться
по полю is_current_location. В случае удачного поиска по данным критериям, счетчик будет повышаться, если же поиск выдаст
нам пустой список, в таком случае будет создана новая запись в [первой таблице](#1-user_request_history).
Поле updated_at будет проставляться автоматически при обновлении строки в базе данных. При создании будет выставляться
текущее время.
2. Когда программа дойдет до этапа отправления запроса в `openweathermap` будет происходить заполнение
[второй таблицы](#2-request_params_to_openweather).
3. При получении ответа от `openweathermap` заполним [третью таблицу](#3-response_from_openweather).
4. После полного прохода по всем этапам, необходим заполнить [связующую таблицу](#4-request_response_connection).
По этой таблице мы и будем выводить информацию пользователю на его запрос об истории в консоль.
На мой взгляд здесь вполне будет удобно использовать ORM, например `DjangoORM`. Это значительно упростит взаимодействия
с базой данных.
5. Заполнение [таблицы пользовательских настроек](#5-user_preferences) происходит при первом [запуске приложения](#41-знакомство-с-пользователем).
или же при вызове команды [`\внастройки`](#4-пользовательские-настройки-команда-внастройки).

### 3.2 Отображение данных

Для пародии на UI-интерфейс в консоли воспользуемся библиотекой [`rich`](https://rich.readthedocs.io/en/latest/introduction.html).

Историю пользователя будем выводить в формате: 

`i. 'название города, страна (если имеется)' или 'текущая локация', время последнего запроса`

Сортировка будет происходить по количеству повторений этого запроса.

Далее пользователю будет предложено повторить этот запрос или показать выбранный запрос.
В случае демонстрации выбранного запроса пользователю будет показываться его последний запрос
(определение последнего запроса будет происходить по полю **response_time** в [третьей таблице](#3-response_from_openweather).

В случае, если была выбрана опция __повторить запрос__:

|                          |                             |
|:------------------------:|:---------------------------:|
|    **Текущее время**     |  2023-10-03 09:48:47+03:00  |
|   **Название города**    |       Санкт-Петербург       |
|   **Погодные условия**   |           облачно           |
| **Текущая температура**  |   12 градусов по цельсию    |
|    **Ощущается как**     |   11 градусов по цельсию    |
|    **Скорость ветра**    |            5 м/c            |

В случае отображения данных из истории:

|                         |                             |
|:-----------------------:|:---------------------------:|
|   **Время обращения**   |  2023-10-03 09:48:47+03:00  |
|   **Название города**   |       Санкт-Петербург       |
|  **Погодные условия**   |           облачно           |
| **Текущая температура** |   12 градусов по цельсию    |
|    **Ощущается как**    |   11 градусов по цельсию    |
|   **Скорость ветра**    |            5 м/c            |

## 4. Интерфейс программы и возможные неприятности

### 4.1. Знакомство с пользователем
Отображение приветственного сообщения. Также в этом случае узнаем у пользователя предпочтения по языку.
Узнаем какую систему единиц измерения предпочитает пользователь (метрическую, имперскую или как на физике xD).
Необходимо ли ему отображать инструкцию использования приложения при каждом запуске. Отобразим инструкцию использования 
приложения (если приложение было запущено впервые или если включена настройка по отображению инструкции
при запуске.
### 4.2 Общие сведения

На старте программы пользователь сможет вводить несколько команд:
`\вгороде`, `\влокации`, `\висторию`, `\внастройки`

#### 1. Погода по названию города, команда '\вгороде'

После вызова пользователем команды `\вгороде`  в консоли программа будет ожидать от него данные
в нескольких форматах: либо `город, страна`, либо `город`.
Далее пользователю в консоли отобразится табличка с информацией о погоде, представленная в пункте [3.2](#32-отображение-данных),
либо сообщение об ошибке:
1. Нет подключения к интернету:
    `ConnectionError` от `requests` или `googletrans`. В данном случае попросим пользователя проверить соединение.
2. Проблемы с одним или несколькими API:
    `сode`: `50*`. В таком случае можно воспользоваться декоратором из 4ого задания и попытаться отправить повторные запросы.
    Если спустя установленное количество попыток ответ так и не будет получен, выведем пользователю сообщение, что
    сервисы недоступны и необходимо попробовать позже.
3. Пользователь ввел некорректные данные 
   В данном случае мы можем споткнуться в нескольких моментах: 
   1. `geocoding api` выдал `code`: `404`. 
   2. Проблемы с переводчиком `Timeout`, `RequestError`. Серверы гугл сказали "пока.."
   3. Проблемы с `pycountry`: `AttributeError`, `LookupError`, - если страна не найдена.
   
   В данном случае будем просить пользователя проверить корректность введенных данных.
4. Валидация данных от пользователя. Программа не должна получать ничего, кроме символов (букв). При получении в строке
чисел или чего-то непонятного будет выводиться сообщение о некорректном формате ввода данных.

#### 2. Погода по текущей локации, команда '\влокации'
После вызова пользователем команды `\влокации`  в консоли отобразится табличка с информацией о погоде, 
представленная в пункте [3.2](#32-отображение-данных), либо сообщение об ошибке:
1. Нет подключения к интернету:
    `ConnectionError` от `requests`. В данном случае попросим пользователя проверить соединение.
2. Проблемы с одним или несколькими API:
    `сode`: `50*`. В таком случае можно воспользоваться декоратором из 4ого задания и попытаться отправить повторные запросы.
    Если спустя установленное количество попыток ответ так и не будет получен, выведем пользователю сообщение, что
    сервисы недоступны и необходимо попробовать позже.
3.`geocoder` в статусе запросе возвращает собственные ошибки:
   1. ZERO_RESULTS - В случае если IP не может быть определен (впн, прокси, локальная сетка).
   2. REQUEST_DENIED - В случае если происходит спам запросами.
   
    Выведем соответствующее сообщение о неполадках с определением IP и просьбой проверки впн, прокси или же предупреждение о том,
    что запросы очень частые.

#### 3. История запросов пользователя, команда '\висторию'
После вызова пользователем команды `\висторию` в консоли отобразится таблица с историей. 
Вывод истории был подробно описан в пункте [3.2](#32-отображение-данных).
Далее пользователь выбирает строку, вводя соответствующий номер. Затем он получает сообщение с предложением
выбрать один из вариантов:
1. Повторить запрос (например нужно будет нажать клавишу R)
2. Показать данные по этому запросу из бд (например нужно будет нажать клавишу H)
Для считывания клавиш можно воспользоваться библиотекой [`keyboard`](https://pypi.org/project/keyboard/)

#### 4. Пользовательские настройки, команда '\внастройки'

После вызова пользователем команды `\внастройки` в консоли поочередно будут выводиться сообщения.
Формат сообщения: `название текщей настроки: (текущее значение) [ожидаемый формат]`. Далее пользователю остается ввести необходимые данные.
В данном случае также необходимо проводить валидацию данных и выводить сообщение, если формат неверен.


   
    



